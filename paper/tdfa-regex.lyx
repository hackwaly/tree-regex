#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\begin_preamble
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\frenchspacing
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Efficient regexp implementation for finding the longest matching groups
\end_layout

\begin_layout Abstract
The 
\shape smallcaps
posix
\shape default
 standard seems inconsistent in that it prescribes on one hand to prefer
 the longest and left-most overall match but the rightmost possible subgroup
 within that match.
 While this seems reasonable if one is familiar with typical implementations,
 it can lead to unintuitive matches.
 For regexp
\family typewriter
 ((a*)b)+
\family default
 and string 
\family typewriter
aaabb
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\family typewriter
"aaabb" =~ "((a*)b)+" :: [[String]]
\end_layout

\end_inset

,
\family default
 one might expect to the subgroup to match 
\family typewriter
aaa
\family default
, i.e.
 the longest match, but by 
\shape smallcaps
posix
\shape default
 standard 1003.1, the empty string is the result instead, i.e.
 the right-most matching group.
\end_layout

\begin_layout Abstract
The more intuitive match does not lead to any asymptotic slowdown, as we
 will show.
 The TDFA by Laurikari
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 can be modified using our proposed 
\shape smallcaps
hierarchical commits
\shape default
 to lead to intuitive matches without slower asymptotic performance.
\end_layout

\begin_layout Abstract
Additionally, we present a prototypical implementation with benchmarks,
 which outperforms the Java regex implementation both asymptotically and
 in practice.
 In practice, we perceive an average speedup of XXX.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The 
\shape smallcaps
posix
\shape default
 standard seems inconsistent in that it prescribes on the one hand to prefer
 the longest and left-most overall match but the rightmost possible subgroup
 within that match.
 While this seems reasonable from an implementational point of view, it
 can lead to unintuitive matches from a user's point of view.
 
\end_layout

\begin_layout Standard
In the following example, 
\begin_inset Quotes eld
\end_inset

?:
\begin_inset Quotes erd
\end_inset

 is used to denote a non-capturing group.
 In POSIX syntax, the bracket characters serve double duty: they both determine
 the binding of operators, and they introduce a new capture group.
 A capture group is a sub-part of the regex.
 After matching the regex on some input, part of the input may match.
 However, just a part of the match is captured by the capture group.
 Modern regex libraries are able to return such submatches.
 A non-capturing group means that we use the brackets only for binding,
 not for defining a new capture group.
 
\end_layout

\begin_layout Standard
Consider the example of regexp
\family typewriter
 (?:(a*)b)+
\family default
 and input string 
\family typewriter
aaabb.
 Here,
\family default
 one might expect the capture group to match 
\family typewriter
aaa
\family default
, i.e.
 the longest match, but by 
\shape smallcaps
posix
\shape default
 standard 1003.1, the empty string is the result instead, i.e.
 the right-most matching set of characters.
\end_layout

\begin_layout Standard
Performance-wise, trying to get the longest match in a back-tracking implementat
ion means that all paths through the NFA must be tried exhaustively.
 Fortunately, as we will demonstrate, the more intuitive matching characteristic
s can be implemented as a slight modification to TDFAs at no asymptotic
 cost.
 
\end_layout

\begin_layout Standard
The algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 uses 
\begin_inset Quotes eld
\end_inset

Tagged NFAs
\begin_inset Quotes erd
\end_inset

 in which some transitions tag the resulting state.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is a tag?
\end_layout

\end_inset

A tagged state 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 is neither equivalent to the untagged state 
\begin_inset Formula $s_{0}$
\end_inset

 nor the same state tagged at a different time 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

.
 To ensure that there are only finitely different tagged states--and thus
 to ensure that the conversion to a DFA terminates--, 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 and 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

 (but not 
\begin_inset Formula $s_{0}$
\end_inset

) are understood to be in conflict.
 Conflicts are resolved with priorities being attached to the transitions,
 e.g.
 the greedy consumption in 
\family typewriter
a*
\family default
 will have priority over other transitions and thus a tag that is produced
 right after such a transition is prefered to another, that resulted from
 a forward 
\begin_inset Formula $\varepsilon$
\end_inset

\SpecialChar \nobreakdash-
transition.
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-TNFA-algorithm"

\end_inset

, the TNFA algorithm is presented so that the modifications in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TNFA-with-hierarchical"

\end_inset

 can be understood more easily.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
This is the age of big data, and the first step of processing big data is
 often to parse strings.
 As an example, consider log files..
 What makes data huge is typically repetition.
 As Jacobs
\begin_inset CommandInset citation
LatexCommand cite
key "Jacobs2009"

\end_inset

 noted, 
\begin_inset Quotes eld
\end_inset

What makes most big data big is repeated observations over time and/ or
 space,
\begin_inset Quotes erd
\end_inset

 and thus log files grow large frequently.
 At the same time, they provide important insight into the process that
 they are logging, so their parsing and understanding is important.
 
\end_layout

\begin_layout Standard
Regular expressions make for scalable and efficient lightweight parsers.
\begin_inset CommandInset citation
LatexCommand cite
key "Karttunen1996"

\end_inset

 
\end_layout

\begin_layout Standard
Regular expression's parsing abilities have evoked Meiners to declare that
 for intrusion detection, 
\begin_inset Quotes eld
\end_inset

fast and scalable RE matching is now a core network security issue.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Meiners2010"

\end_inset


\end_layout

\begin_layout Standard
For example, Arasu et al.
\begin_inset CommandInset citation
LatexCommand cite
key "Arasu2012"

\end_inset

 demonstrate how regular expressions are used in Bing to validate data,
 by checking whether the names of digital cameras in their database are
 valid.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Parsing example!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The posix default is for matches to be as long as possible.
 This makes sense in the context of lightweight parsing: in case there are
 many ways to match subgroups, the shortest ones are often degenerate.
 As an example, parsing a list of names with several telephone numbers for
 each name might contain a 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 to indicate a missing phone number.
 Now, if we parse the telephone numbers of Tom Lehrer using regular expressions,
 "Tom Lehrer Tel 007 -" =~ "^([a-zA-Z ]+) ((Tel [0-9
\backslash

\backslash
-]+|
\backslash

\backslash
-) ?)*", we find that his telephone number is 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

, whereas 
\begin_inset Quotes eld
\end_inset

007
\begin_inset Quotes erd
\end_inset

 would clearly be the better match.
 
\end_layout

\begin_layout Standard
Hierarchical commits help the developer avoid degenerate matches by prefering
 longer matches, and lead to more intuitive subgroup matches.
 At the top level, posix prescribes to match the leftmost longest match.
 At the capture group level, posix prescribes the last match, regardless
 of size.
 Hierarchical commits, instead, choose the longest.
 As an extension, they can even be used to extract 
\emph on
all
\emph default
 matches.
\end_layout

\begin_layout Section
The TDFA powerset construction algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:The-TNFA-algorithm"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\naturals}{\mathbb{N}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\integers}{\mathbb{Z}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pos}{\mathbf{\mathbf{p}}}
\end_inset

Our algorithm is a modification of Laurikari's algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

, which is itself a modified powerset construction algorithm 
\begin_inset CommandInset citation
LatexCommand cite
after "p. 55"
key "Sipser2005"

\end_inset

.
 For clarity, and because the original description contains a few errors,
 we outline his algorithm here, omitting his proof for correctness and terminati
on.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
 In the TNFA algorithm, the state of the machine is not only determined
 by the position in the state graph, but also by a number of positions in
 the string that is read, that can later be used to construct the subgroups
 of the match.
 
\end_layout

\end_inset

 Our representation closely follows the one by Sipser 
\begin_inset CommandInset citation
LatexCommand cite
after "p. 55"
key "Sipser2005"

\end_inset

.
\end_layout

\begin_layout Standard
Our algorithm creates instructions that are executed at runtime, i.e.
 during the interpretation of the TDFA.
 There are two possible instructions for 
\begin_inset Formula $n,m\in\naturals$
\end_inset

:
\end_layout

\begin_layout Description
\begin_inset Formula $n\leftarrow\mathbf{p}$
\end_inset

 Stores the current position in the input string into memory location 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Formula $n\leftarrow m$
\end_inset

 Stores the contents of memory location 
\begin_inset Formula $m$
\end_inset

 into memory location 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TDFA from TNFA
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Function{SimpleStep}{$nfa$, $node$, $r$} 
\end_layout

\begin_layout Plain Layout

	
\backslash
State 
\backslash
Return $
\backslash
left
\backslash
{(n, m_{t_c}, priority): (node, n, r, t, priority) 
\backslash
in nfa.transitions
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

										
\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{ResolveConflicts}{$map$}
\end_layout

\begin_layout Plain Layout


\backslash
State $flat 
\backslash
gets 
\backslash
text{recusively all } keys 
\backslash
text{ of } map$
\end_layout

\begin_layout Plain Layout


\backslash
ForAll{distict $N_1 = (n, m_{t_1}, p_1), N_2 = (n, m_{t_2}, p_2) 
\backslash
in flat$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$p_2 > p_1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State remove $N_1$ from map
\backslash
Comment{Also removes dependent states}
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State remove $N_2$ from map
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return flat
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

										
\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{Step}{$nfa$, $node$, $read$}
\end_layout

\begin_layout Plain Layout


\backslash
State $direct 
\backslash
gets 
\backslash
Call{SimpleStep}{nfa, node, read}$
\end_layout

\begin_layout Plain Layout


\backslash
State $map 
\backslash
gets Map(n 
\backslash
rightarrow step(nfa, n, 
\backslash
varepsilon) : n 
\backslash
in direct)$
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return 
\backslash
Call{ResolveConflicts}{map}
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

										
\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{PushStates}{nfa, dfa, start}
\end_layout

\begin_layout Plain Layout


\backslash
State $open 
\backslash
gets 
\backslash
{start
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
State $towards 
\backslash
gets 
\backslash
text{empty }Map
\backslash
left[readable 
\backslash
rightarrow Set
\backslash
left[NfaState
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout


\backslash
While{$open 
\backslash
neq 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $first:open 
\backslash
gets open$
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$state_{nfa} 
\backslash
in first$ and valid inputs $r$ from $state_{nfa}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $towards[r] 
\backslash
gets towards 
\backslash
cup 
\backslash
Call{step}{nfa, state_{nfa}, r}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
State $dfa.transitions, newnodes 
\backslash
gets 
\backslash
Call{Merge}{dfa.transitions, towards}$
\end_layout

\begin_layout Plain Layout

			
\backslash
Statex 
\backslash
Comment{Merge represents the match strategy}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return dfa
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

										
\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{CreateDfa}{nfa}
\end_layout

\begin_layout Plain Layout


\backslash
State initialize empty dfa
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa.start 
\backslash
gets nfa.start 
\backslash
cup 
\backslash
Call{Step}{nfa, nfa.start, 
\backslash
varepsilon}$
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa 
\backslash
gets 
\backslash
Call{PushStates}{nfa, dfa, dfa.start}$
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa.ends 
\backslash
gets 
\backslash
{n
\backslash
in dfa.states : n
\backslash
cap nfa.ends 
\backslash
neq 
\backslash
emptyset
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return dfa
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
For 
\begin_inset Formula $I\subset\naturals$
\end_inset

 and 
\begin_inset Formula $n\in\naturals$
\end_inset

, DFA state
\begin_inset Formula $\{(q_{i},(a_{ij})_{j=1..n}):i\in I\}$
\end_inset

 is 
\emph on
mappable
\emph default
 to another DFA state 
\begin_inset Formula $\{(q_{i},(b_{ij})_{j=1..n}):i\in I\}$
\end_inset

 iff there is a bijection 
\begin_inset Formula $\nu$
\end_inset

 such that 
\begin_inset Formula $\forall i\in I,\, j=1..n:\,(a_{ij})=(\nu(b_{ij}))$
\end_inset

.
 Bijection 
\begin_inset Formula $\nu$
\end_inset

 is called the 
\emph on
mapping
\emph default
.
\begin_inset Newline newline
\end_inset

For example, 
\begin_inset Formula $\{(q_{0},[4,3]),\,(q_{1},[2,1]),\,(q_{3},[2,3])\}$
\end_inset

 is mappable to 
\begin_inset Formula $\{(q_{0},[0,-2]),\,(q_{1},[2,1]),\,(q_{3},[2,-2])\}$
\end_inset

 using mapping 
\begin_inset Formula $1\mapsto1,\,3\mapsto-2,\,4\mapsto0$
\end_inset

.
\end_layout

\begin_layout Definition
Let us first consider the caase where 
\begin_inset Formula $N$
\end_inset

 has no 
\begin_inset Formula $\epsilon$
\end_inset

 arrows and no tags.
 Then we can construct the new transition function 
\begin_inset Formula $\delta'$
\end_inset

 as follows:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\delta'(R,a)=\bigcup_{r\in R}\delta(r,a)\mbox{.}
\]

\end_inset


\end_layout

\begin_layout Definition
Now we need to consider the 
\begin_inset Formula $\epsilon$
\end_inset

 arrows, some of which contain tags.
 We use the following notation:
\end_layout

\begin_layout Definition
For any state 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 we define 
\begin_inset Formula $E(R)=\bigcup_{(r,t)\in R}e(q,t)$
\end_inset

 to be a set of pairs.
 The first elements of the pairs are the states that can be reached from
 
\begin_inset Formula $R$
\end_inset

 by going along only 
\begin_inset Formula $\epsilon$
\end_inset

-arrows, including the members of 
\begin_inset Formula $R$
\end_inset

 themselves.
 The second element of each pair denotes the memory locations of all tags
 for their corresponding NFA state.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Still a bit cryptic.
\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
Name:   
\begin_inset Formula $e(q,t)$
\end_inset


\end_layout

\begin_layout LyX-Code
Global variables: a result list 
\begin_inset Formula $R$
\end_inset

 (initially empty), 
\end_layout

\begin_deeper
\begin_layout LyX-Code
integer counter 
\begin_inset Formula $c$
\end_inset

 (initially 
\begin_inset Formula $0$
\end_inset

)
\end_layout

\end_deeper
\begin_layout LyX-Code
Input:  DFA state 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout LyX-Code
Output: 
\begin_inset Formula $R$
\end_inset

 is the new DFA state
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
For all 
\begin_inset Formula $(q',t')\in AARON!$
\end_inset

, where 
\begin_inset Formula $q'$
\end_inset

 is reached by a depth first search starting from all 
\begin_inset Formula $q$
\end_inset

 where 
\begin_inset Formula $(q,t)\in Q$
\end_inset

 that are reached by depth first search along 
\begin_inset Formula $\epsilon$
\end_inset

-arrows, starting from 
\begin_inset Formula $q$
\end_inset

 
\end_layout

\begin_layout LyX-Code
For all NFA states 
\begin_inset Formula $q'$
\end_inset

 that can be reached from 
\begin_inset Formula $q$
\end_inset

 by traveling along exactly one 
\end_layout

\begin_layout LyX-Code
\begin_inset Formula $\epsilon$
\end_inset

-arrow do
\end_layout

\begin_deeper
\begin_layout LyX-Code
1.
 Resolve conflicts:
\end_layout

\begin_layout LyX-Code
if there is a 
\begin_inset Formula $(q',\hat{t})\in R$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
and the transition from 
\begin_inset Formula $q$
\end_inset

 to 
\begin_inset Formula $q'$
\end_inset

 has negative priority then
\end_layout

\begin_deeper
\begin_layout LyX-Code
continue with the next 
\begin_inset Formula $q'$
\end_inset

 in the for loop.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
end if
\end_layout

\begin_layout LyX-Code
2.
 Build closure:
\end_layout

\begin_layout LyX-Code
if the transition from 
\begin_inset Formula $q$
\end_inset

 to 
\begin_inset Formula $q'$
\end_inset

 is tagged with tag 
\begin_inset Formula $\tau_{k}$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
let 
\begin_inset Formula $t'$
\end_inset

 be 
\begin_inset Formula $[t_{1},\dots,t_{k-1},c,t_{k+1},\dots,t_{n}]$
\end_inset


\end_layout

\begin_layout LyX-Code
increment 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout LyX-Code
set 
\begin_inset Formula $R'$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Formula $e(q',t')$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
else
\end_layout

\begin_deeper
\begin_layout LyX-Code
set 
\begin_inset Formula $R'$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Formula $e(q',t)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
end if
\end_layout

\begin_layout LyX-Code
3.
 add all elements of 
\begin_inset Formula $R'$
\end_inset

 to 
\begin_inset Formula $R$
\end_inset

, overwriting with 
\begin_inset Formula $R'$
\end_inset

 taking precedence:
\begin_inset Note Note
status open

\begin_layout Plain Layout
Are conflicts still solved?
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
set 
\begin_inset Formula $R$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Formula $(R'\cup R)\setminus\{(\hat{q},\hat{t})\in R':\exists(\hat{q},\tilde{t})\in R\}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
end for
\end_layout

\begin_layout LyX-Code
return 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Compute the closure of state 
\begin_inset Formula $M$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\delta^{\star}(R,a)=\{q\in Q:q\in E(\delta(r,a))\text{ for some }r\in R\}
\]

\end_inset


\end_layout

\begin_layout Section
TDFA with hierarchica l commits
\begin_inset CommandInset label
LatexCommand label
name "sec:TNFA-with-hierarchical"

\end_inset


\end_layout

\begin_layout Standard
A run is a pair 
\begin_inset Formula $(a,b)\in\naturals^{2}$
\end_inset

, where 
\begin_inset Formula $a$
\end_inset

 stands for the starting position of a run in a string,
\end_layout

\begin_layout Standard
The overall idea is simple: whenever the TDFA is reading in a run of characters
 that belong to a capture group, we compare the currently read run to the
 previously best one.
 For example, when the TDFA produced by ((a+)b|a)+ reads in the string aabaaa,
 it will proceed as follows.
 Upon reading b, it keeps the run 
\begin_inset Quotes eld
\end_inset

aa
\begin_inset Quotes erd
\end_inset

 as the currently best match for the inner capture group of the regex, since
 that capture group had no better match before that.
 Then it will try to generate a longer match for this capture group, reading
 
\begin_inset Quotes eld
\end_inset

aaa
\begin_inset Quotes erd
\end_inset

, but since there is no 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 in the end of the string, it will not commit, therefore leaving the best
 match at 
\begin_inset Quotes eld
\end_inset

aa
\begin_inset Quotes erd
\end_inset

.
 On the other hand, if the string was indeed 
\begin_inset Quotes eld
\end_inset

aabaaab
\begin_inset Quotes erd
\end_inset

, the commit would take place and since 
\begin_inset Quotes eld
\end_inset

aaa
\begin_inset Quotes erd
\end_inset

 is longer than 
\begin_inset Quotes eld
\end_inset

aa
\begin_inset Quotes erd
\end_inset

, the commit would overwrite the old one.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Aaron: maybe better include the blackboard picture here, but improve it
 into a complete example.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To implement these comparisons, we introduce 
\begin_inset Quotes eld
\end_inset

hierarchical commits
\begin_inset Quotes erd
\end_inset

 into the TDFA.
 Since capture groups are nested, they form a tree.
 Every node of this tree stands for one capture group, and we shall call
 it a 
\emph on
hierarchy node
\emph default
.
 In it, we store all runs that this capture group matches.
 The subnodes of a hierarchy nodes correspond to the submatches of its capture
 group.We will shortly discuss how to construct a TDFA that includes instructions
 that 
\emph on
commit
\emph default
 submatches into the hierarchy nodes..
 Once we have the instructions, during interpretation of the TDFA, whenever
 we encounter an input character that closes a capture group, the TDFA will
 
\emph on
commit
\emph default
 that capture group.
 To commit a substring into a hierarchy node has the following semantics.
\end_layout

\begin_layout Standard
A hierarchy node, as a tree node, has a corresponding subtree.
 The data in this subtree represents precisely the subtree of the AST that
 is currently being matched.
 Upon commit of the hierarchy node, it constructs this AST subtree, and
 stores it as a previous match.
 Iteratively, this produces all matches of all capture groups.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/lehrer_match.pdf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/lehrer_after.pdf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Matching 
\family typewriter
(
\backslash
w+) (
\backslash
w+)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
if the current set of characters compare the current reading with the previously
 longest read, keeping the longer one.
 n order to get some more control over the overwriting of the tags, a separate
 
\family typewriter
commit
\family default
 step can be introduced.
 Each nesting then would need a separate copy of the temporary 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 match for a given group.
 For example 
\family typewriter
(((a+)b)+c)+
\family default
 would need two additional copies of the innermost group, to handle conflicts.
 
\end_layout

\begin_layout Plain Layout
The intuition is to notice that two tags -- the opening and the corresponding
 end tag -- always appear in order and the inner groups should not spill
 over the end of the outer group.
 After each closing tag then a commit is made, which handles whether the
 new or the old match is longer.
 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Example
\end_layout

\begin_layout Standard
In the following, the regex 
\family typewriter
(?:(?:(a+)b)+c)+
\family default
 will be converted to a 
\shape smallcaps
dfa
\shape default
.
 First, it is converted to a 
\shape smallcaps
nfa
\shape default
:
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename graphs/standard_example.svg
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
NFA about to be transformed.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen, the 
\shape smallcaps
dfa
\shape default
 start node is just 
\begin_inset Formula $\{s_{1}\}$
\end_inset

, since no 
\begin_inset Formula $\varepsilon$
\end_inset

-steps are possible.
 Now the states are extended using a breadth first search: 
\end_layout

\begin_layout Enumerate
\begin_inset Formula ${s_{1}}\xrightarrow{a}{s_{2}m_{t}^{0}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula ${s_{2}m_{t}^{0}}\xrightarrow{a}{s_{2}m_{t}^{0}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula ${s_{2}m_{t}^{0}}\xrightarrow{b}{s_{3}m_{t}^{0}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
This technique allows for programmers to extract parts of text with great
 performance and flexibility regarding the extracted match.
 One could imagine, that a programmer needs to extract a ideally complete
 sample of formated text with optional parameters.
 Here, 
\family typewriter
\shape smallcaps
posix
\family default
\shape default
 regex would fail to deliver the best match in most cases.
 Such cases can occur in data mining, in bioinformatics, both of which are
 handling massive data, so that efficiency can be a problem.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Benchmarks
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section
Open questions
\end_layout

\begin_layout Standard
The cost of matching an input string of length 
\begin_inset Formula $n$
\end_inset

 with a regex of length 
\begin_inset Formula $r$
\end_inset

 is 
\begin_inset Formula $O(2^{r}+n)$
\end_inset

.
 Clearly, for small 
\begin_inset Formula $n$
\end_inset

 and big 
\begin_inset Formula $r$
\end_inset

, Thompson's algorithm 
\begin_inset CommandInset citation
LatexCommand cite
after "p. 293"
key "Sedgewick1990"

\end_inset

 at cost 
\begin_inset Formula $O(nr)$
\end_inset

 is preferable.
 However, it is still an open question whether Thompson's algorithm can
 be adapted to subgroup matching.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio"
options "plain"

\end_inset


\end_layout

\begin_layout Section*
Notes: 
\end_layout

\begin_layout Standard
Pseudocode
\end_layout

\begin_layout Standard
Beispiel(e) '(?:(?:(a+)b)+c)+'
\end_layout

\begin_layout Standard
Algorithm:
\end_layout

\begin_layout Standard
Definition:
\end_layout

\end_body
\end_document
