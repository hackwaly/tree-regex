#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Efficient regexp implementation for finding the longest matching groups
\end_layout

\begin_layout Abstract
The 
\shape smallcaps
posix
\shape default
 standard seems inconsistent in that it prescribes on one hand to prefer
 the longest and left-most match but the right-most combination no matter
 the length.
 While this seems reasonable if one is familiar with typical implementations,
 it can lead to unintuitive matches: 
\end_layout

\begin_layout Abstract
Given the regexp
\begin_inset Foot
status open

\begin_layout Plain Layout
Non-capturing groups will be used to simplify examples.
\end_layout

\end_inset

 
\family typewriter
(?:(a*)b)+
\family default
 and the string 
\family typewriter
aaabb
\family default
 one might expect to match 
\family typewriter
aaa
\family default
, i.e.
 the longest match, but by 
\shape smallcaps
posix
\shape default
 standard 1003.1, the empty string is the result instead, i.e.
 the right-most matching group.
\end_layout

\begin_layout Abstract
The more intuitive match does not lead to efficiency problems.
 As we will show, the TDFA algorithm by Laurikari
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 can be modified using hierarchical commits to give an algorithm with only
 a linear slowdown in the depth of the capture group nesting in the worst
 case.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 uses NFAs in which some transitions tag the resulting state.
 A tagged state 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 is neither equivalent to the untagged state 
\begin_inset Formula $s_{0}$
\end_inset

 nor the same state tagged at a different time 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

.
 To ensure that there are only finitely different tagged states--and thus
 to ensure that the conversion to a DFA terminates--, 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 and 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

 (but not 
\begin_inset Formula $s_{0}$
\end_inset

) are understood to be in conflict.
 Conflicts are resolved with priorities being attached to the transitions,
 e.g.
 the greedy consumption in 
\family typewriter
a*
\family default
 will have priority over other transitions and thus a tag that is produced
 right after such a transition is prefered to another, that resulted from
 a forward 
\begin_inset Formula $\varepsilon$
\end_inset

\SpecialChar \nobreakdash-
transition.
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-TNFA-algorithm"

\end_inset

 the TNFA algorithm is presented so that the modifications in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TNFA-with-hierarchical"

\end_inset

 can be understood more easily.
\end_layout

\begin_layout Section
The TNFA algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:The-TNFA-algorithm"

\end_inset


\end_layout

\begin_layout Section
TNFA with hierarchical commits
\begin_inset CommandInset label
LatexCommand label
name "sec:TNFA-with-hierarchical"

\end_inset


\end_layout

\begin_layout Standard
In order to get some more control over the overwriting of the tags, a separate
 
\family typewriter
commit
\family default
 step can be introduced.
 Each nesting then would need a separate copy of the temporary 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 match for a given group.
 For example 
\family typewriter
(?:(?:(a+)b)+c)+
\family default
 would need two additional copies of the innermost group, to handle conflicts.
 
\end_layout

\begin_layout Standard
The intuition is to notice that two tags -- the opening and the corresponding
 end tag -- always appear in order and the inner groups should not spill
 over the end of the outer group.
 After each closing tag then a commit is made, which handles whether the
 new or the old match is longer.
 
\end_layout

\begin_layout Section
Applications
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio"
options "plain"

\end_inset


\end_layout

\begin_layout Section*
Notes: 
\end_layout

\begin_layout Standard
Pseudocode
\end_layout

\begin_layout Standard
Beispiel(e) '(?:(?:(a+)b)+c)+'
\end_layout

\begin_layout Standard
Algorithm:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
simple_step(nfa, node, read)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
return set of all tagged nodes (n,
\begin_inset Formula $m_{t}$
\end_inset

, priority) for (node, n, read, t, priority) in nfa.transitions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
resolve_conflicts(map)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
flat 
\begin_inset Formula $\leftarrow$
\end_inset

 deep union of keys of map
\end_layout

\begin_layout Plain Layout
return flat if there are no conflicts
\end_layout

\begin_layout Plain Layout
else:
\end_layout

\begin_layout Plain Layout
for all 
\begin_inset Formula $N_{1}=(n,m_{t_{1}},p_{1})$
\end_inset

 in 
\begin_inset Formula $flat$
\end_inset

 and all 
\begin_inset Formula $N_{2}=(n,m_{t_{2}},p_{2})$
\end_inset

 in 
\begin_inset Formula $flat\setminus\{N_{1}\}$
\end_inset


\end_layout

\begin_layout Plain Layout
if 
\begin_inset Formula $p_{2}>p_{1}$
\end_inset


\end_layout

\begin_layout Plain Layout
return resolve_conflicts(remove 
\begin_inset Formula $N_{1}$
\end_inset

from map) // Note that this kills off offspring as well
\end_layout

\begin_layout Plain Layout
else
\end_layout

\begin_layout Plain Layout
return resolve_conflicts(remove 
\begin_inset Formula $N_{2}$
\end_inset

from map)
\end_layout

\begin_layout Plain Layout
end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
step(nfa, node, read)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
direct 
\begin_inset Formula $\leftarrow$
\end_inset

simple_step(nfa, node, read)
\end_layout

\begin_layout Plain Layout
map 
\begin_inset Formula $\leftarrow$
\end_inset

Map(n 
\begin_inset Formula $\rightarrow$
\end_inset

step(nfa, n, 
\begin_inset Formula $\varepsilon$
\end_inset

) for n in direct) // might recur infinitely as of now, um, lets say it's
 a lazy map
\end_layout

\begin_layout Plain Layout
return resolve_conflicts(map)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
push_states(nfa, dfa, open)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
return dfa if open is empty
\end_layout

\begin_layout Plain Layout
else
\end_layout

\begin_layout Plain Layout
first:rest 
\begin_inset Formula $\leftarrow$
\end_inset

 open
\end_layout

\begin_layout Plain Layout
towards = Map[readable 
\begin_inset Formula $\rightarrow$
\end_inset

Set[NfaState]]
\end_layout

\begin_layout Plain Layout
for all nfa_state in first and all valid inputs r from nfa_state
\end_layout

\begin_layout Plain Layout
towards[r] 
\begin_inset Formula $\leftarrow$
\end_inset

towards[r] 
\begin_inset Formula $\cup$
\end_inset

 step(nfa_state)
\end_layout

\begin_layout Plain Layout
end
\end_layout

\begin_layout Plain Layout
dfa.transitions, new_nodes 
\begin_inset Formula $\leftarrow$
\end_inset


\emph on
merge
\emph default
(dfa.transitions, towards)
\end_layout

\begin_layout Plain Layout
return push_states(nfa, dfa, open ++ new_nodes)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
create_dfa(nfa)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
initialize dfa
\end_layout

\begin_layout Plain Layout
dfa.start 
\begin_inset Formula $\leftarrow$
\end_inset

nfa.start 
\begin_inset Formula $\cup$
\end_inset

 step(nfa, nfa.start, 
\begin_inset Formula $\varepsilon$
\end_inset

)
\end_layout

\begin_layout Plain Layout
dfa 
\begin_inset Formula $\leftarrow$
\end_inset

push_states(nfa, dfa, [dfa.start])
\end_layout

\begin_layout Plain Layout
dfa.ends 
\begin_inset Formula $\leftarrow$
\end_inset

[n for n in dfa.states if 
\begin_inset Formula $n\cap nfa.ends\neq\emptyset$
\end_inset

]
\end_layout

\end_inset


\end_layout

\end_body
\end_document
