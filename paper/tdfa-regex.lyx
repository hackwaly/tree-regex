#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass amsart
\begin_preamble
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\frenchspacing
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Efficient regexp implementation for finding parse trees
\end_layout

\begin_layout Abstract
Regular expressions naturally and intuitively define ASTs that describe
 the text that they're parsing.
 We describe a technique for building up the complete parse tree resulting
 from matching a text against a regular expression.
\end_layout

\begin_layout Abstract
In standard TDFA matching, all paths through the NFA are walked simultaneously,
 as if in different threads, where inside each thread, it is fully known
 when which capture group was entered or left.
 We extend this model to keep track of not just the last opening and closing
 of capture groups, but all of them.
 We do this by storing, in every thread, using the fly-weight pattern, a
 history of the all groups.
 Thus, we log enough information during parsing to build up the complete
 AST at the end of parsing.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\regex}{\text{\text{regular expression}}}
\end_inset

A regular expression can easily describe that a text matches a comma separated
 values file, but it is unable to extract all the values.
 Instead it will only give a single instance of values: 
\family typewriter
(([a-zA-Z ]+),(
\backslash
d+);)+
\family default
 might describe a dataset of ASCII names with their numeric label.
 Matching the regular expression on 
\family typewriter

\begin_inset Quotes eld
\end_inset

Tom Lehrer,1;Alan Turing,2;
\begin_inset Quotes erd
\end_inset


\family default
 will confirm that the list is well formed, but the match will only contain
 
\family typewriter

\begin_inset Quotes eld
\end_inset

Tom Lehrer
\begin_inset Quotes erd
\end_inset


\family default
 for the second capture group and 
\family typewriter

\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset


\family default
 for the third.
 We would hope instead that the regular expression would allow us to extract
 both entries.
\end_layout

\begin_layout Standard
The amortized run time of our approach is 
\begin_inset Formula $O(m\: n)$
\end_inset

, where 
\begin_inset Formula $m$
\end_inset

 is the length of the regular expression and 
\begin_inset Formula $n$
\end_inset

 is the length of the parsed string.
 This is asymptotically as fast as the best matchers that don't extract
 parse trees.
 Our approach builds on the work of 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 and uses 
\begin_inset Quotes eld
\end_inset

Tagged NFAs
\begin_inset Quotes erd
\end_inset

 in which some transitions tag the resulting state.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is a tag?
\end_layout

\end_inset

A tagged state 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 is neither equivalent to the untagged state 
\begin_inset Formula $s_{0}$
\end_inset

 nor the same state tagged at a different time 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

.
 Our modifications allow us to to never reach a situation where the tagged
 state later in the algorithm needs to be prefered to the state that is
 found earlier.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
This is the age of big data, and the first step of processing big data is
 often to parse strings.
 As an example, consider log files..
 What makes data huge is typically repetition.
 As Jacobs
\begin_inset CommandInset citation
LatexCommand cite
key "Jacobs2009"

\end_inset

 noted, 
\begin_inset Quotes eld
\end_inset

What makes most big data big is repeated observations over time and/ or
 space,
\begin_inset Quotes erd
\end_inset

 and thus log files grow large frequently.
 At the same time, they provide important insight into the process that
 they are logging, so their parsing and understanding is important.
 
\end_layout

\begin_layout Standard
Regular expressions make for scalable and efficient lightweight parsers.
\begin_inset CommandInset citation
LatexCommand cite
key "Karttunen1996"

\end_inset

 
\end_layout

\begin_layout Standard
Regular expression's parsing abilities have evoked Meiners to declare that
 for intrusion detection, 
\begin_inset Quotes eld
\end_inset

fast and scalable RE matching is now a core network security issue.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Meiners2010"

\end_inset


\end_layout

\begin_layout Standard
For example, Arasu et al.
\begin_inset CommandInset citation
LatexCommand cite
key "Arasu2012"

\end_inset

 demonstrate how regular expressions are used in Bing to validate data,
 by checking whether the names of digital cameras in their database are
 valid.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Parsing example!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Parsers that can return abstract syntax trees are more useful than ones
 that only give a flat list of matches.
 Of course only regular grammars can be matched by our approach.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
While there is no shortage of books discussing the usage of regular expressions,
 the implementation side of regular expression has not been so lucky.
 Cox is spot-on when he argues that innovations have repeatedly been ignored
 and later reinvented 
\begin_inset CommandInset citation
LatexCommand cite
key "Cox2007"

\end_inset

.
 
\end_layout

\begin_layout Standard
This paper is no exception.
 The authors of this paper had set out to implement Laurikari's TDFA algorithm
 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

, only to discover that Laurikari's description of a TDFA is so far from
 complete that it can rightfully only be called the sketch for an algorithm.
 Only late in the process did we discover that the blanks had already been
 filled by Kuklewicz in the course of his implementation of TDFAs in Haskell
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kuklewicz2007"

\end_inset

.
 Kuklewicz enshrined his added insight into Haskell library, but never published
 the algorithm as a whole.
 If the history of regular expressions is evidence of one thing, it is that
 source code is a terrible medium to convey algorithms.
 
\end_layout

\begin_layout Standard
The situation dramatically improved with Cox's simple and concise explanation
 of regular expression matching 
\begin_inset CommandInset citation
LatexCommand cite
key "Cox2007"

\end_inset

.
 It seems ironic that this well-versed author published his influential
 work on his website.
 Although the joke may be on Academia's side.
\end_layout

\begin_layout Standard
When the taciturn practioners acknowledge each other's work, we can't help
 but disagree almost universally with the characterizations they produce.
 Sulzmann and Lu 
\begin_inset CommandInset citation
LatexCommand cite
key "sulzmann2012regular"

\end_inset

 call Kuklewicz's work an 
\begin_inset Quotes eld
\end_inset

implementation
\begin_inset Quotes erd
\end_inset

 of Laurikari's algorithm, although Laurikari's algorithm is far too incomplete
 for that statement to be fair.
 Laurikari's algorithm is referred to as a POSIX-style automaton.
 In truth, Laurikari leaves the matching strategy entirely open.
 It was Kuklewicz that found out how to get POSIX-style matching out of
 Laurikari's TDFA.
 
\end_layout

\begin_layout Standard
Cox says that Laurikari's TDFA is a reinvention Pike's published only in
 code algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "Pike1987"

\end_inset

, which is Thompson's NFA with submatch tracking.
 This seems unfair in that Laurikari's allows for far more aggressive reusing
 of old states than what Thompson allows.
 This should lead to Laurikari's TDFA having fewer states, and therefore
 better performance, than even Google's RE2, which uses Pike's algorithm.
 This is not confirmed by the benchmarks by Sulzmann and Lu 
\begin_inset CommandInset citation
LatexCommand cite
key "sulzmann2012regular"

\end_inset

, but they offer an explanation: in their profiling, they see that all Haskell
 implementations spend considerable time decoding the input strings.
 In other words, the measured performance is more of an artifact of the
 programming environment used.
 
\end_layout

\begin_layout Standard
Another mistake that permeates the scarce literature is to call regular
 expression matching linear.
 As Sedgewick points out correctly 
\begin_inset CommandInset citation
LatexCommand cite
key "Sedgewick1990"

\end_inset

, Thompson's NFA matching is of complexity 
\begin_inset Formula $O(mn)$
\end_inset

, where 
\begin_inset Formula $m$
\end_inset

 is the size of the input NFA, and 
\begin_inset Formula $n$
\end_inset

 is the size of the input string.
 To call this linear requires to assume 
\begin_inset Formula $m$
\end_inset

 to be fix, which we cannot bring ourselves to justify.
 It may well be true that, at present, 
\begin_inset Formula $m$
\end_inset

 tends to be small.
 But that is a natural consequence of the algorithms not scaling very well
 with 
\begin_inset Formula $m$
\end_inset

.
 If they did, that would allow for fast feature extracting from text.
 Therefore, in this paper, we consider the state of the art algorithms to
 be quadratic, since both 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are part of the input to a regular expression matcher.
 We cannot rule out that a linear algorithm exists, in fact, we hope for
 it.
 To insist that regular expression matching is done in linear time is to
 insist that the optimal algorithm has already been found; that is probably
 not true.
\end_layout

\begin_layout Standard
Sulzmann and Lu add to the table a new matching strategy that yields good
 practical performance, although the theoretical bounds are considerably
 worse than the state of the art, at 
\begin_inset Formula $O(n^{2}m)$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "sulzmann2012regular"

\end_inset

.
\end_layout

\begin_layout Section
The TDFA powerset construction algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:The-TNFA-algorithm"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\naturals}{\mathbb{N}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\integers}{\mathbb{Z}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pos}{\mathbf{\mathbf{p}}}
\end_inset

Our algorithm is a modification of Laurikari's algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

, which is itself a modified powerset construction algorithm 
\begin_inset CommandInset citation
LatexCommand cite
after "p. 55"
key "Sipser2005"

\end_inset

.
 However instead of compiling the TNFA to a TDFA before matching, we create
 the TDFA lazily as we match the string.
 For clarity, and because the original description contains a few errors,
 we outline his algorithm here, omitting his proof for correctness and terminati
on.
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
 In the TNFA algorithm, the state of the machine is not only determined
 by the position in the state graph, but also by a number of positions in
 the string that is read, that can later be used to construct the subgroups
 of the match.
 
\end_layout

\end_inset

 Our description adapts the thread metaphor of 
\begin_inset CommandInset citation
LatexCommand cite
key "Cox2007"

\end_inset

, where each (T)NFA state describes the state of a single thread in a virtual
 machine and the (T)DFA state is a collection of such threads.
\end_layout

\begin_layout Standard
Our algorithm runs two phases for each character read.
 First it creates a new TDFA state from the current state and tries to map
 this state and the instructions on the transition to a known state(as in
 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

), then it executes the instructions found.
\end_layout

\begin_layout Standard
The memory model differs from other regular expression engines in that locations
 are not stored in a fixed number of cells.
 Instead each cell is the head of a singly linked list that describes the
 history of the value.
 This allows us to extract all capture groups matching a subpattern after
 the matching phase ended.
 Whenever threads are forked, the histories of the matches sofar are shared,
 but we ensure that further modifications will be thread-bound.
\end_layout

\begin_layout Standard
We need the following instructions:
\end_layout

\begin_layout Description
\begin_inset Formula $n\leftarrow\mathbf{p}$
\end_inset

 Stores the current position in the input string into the head of memory
 location 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Formula $n\leftarrow\pos+1$
\end_inset

 Stores the position after the current one in the input string into the
 head of memory location 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Formula $n\leftarrow m$
\end_inset

 Replaces memory location 
\begin_inset Formula $m$
\end_inset

 with a copy of head and history of memory location 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Description
\begin_inset Formula $c\uparrow(n)$
\end_inset

, 
\begin_inset Formula $c\downarrow(n)$
\end_inset

 Puts the current state of memory location 
\begin_inset Formula $n$
\end_inset

 into the tail of the same memory location.
 The two instructions don't differ in their effect, but in the order in
 which they are executed.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	Name: 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TDFA from TNFA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
For 
\begin_inset Formula $I\subset\naturals$
\end_inset

 and 
\begin_inset Formula $n\in\naturals$
\end_inset

, DFA state
\begin_inset Formula $\{(q_{i},(a_{ij})_{j=1..n}):i\in I\}$
\end_inset

 is 
\emph on
mappable
\emph default
 to another DFA state 
\begin_inset Formula $\{(q_{i},(b_{ij})_{j=1..n}):i\in I\}$
\end_inset

 iff there is a bijection 
\begin_inset Formula $\nu$
\end_inset

 such that 
\begin_inset Formula $\forall i\in I,\, j=1..n:\,(a_{ij})=(\nu(b_{ij}))$
\end_inset

.
 Bijection 
\begin_inset Formula $\nu$
\end_inset

 is called the 
\emph on
mapping
\emph default
.
\begin_inset Newline newline
\end_inset

For example, 
\begin_inset Formula $\{(q_{0},[4,3]),\,(q_{1},[2,1]),\,(q_{3},[2,3])\}$
\end_inset

 is mappable to 
\begin_inset Formula $\{(q_{0},[0,-2]),\,(q_{1},[2,1]),\,(q_{3},[2,-2])\}$
\end_inset

 using mapping 
\begin_inset Formula $1\mapsto1,\,3\mapsto-2,\,4\mapsto0$
\end_inset

.
\end_layout

\begin_layout Definition
Let us first consider the caase where 
\begin_inset Formula $N$
\end_inset

 has no 
\begin_inset Formula $\epsilon$
\end_inset

 arrows and no tags.
 Then we can construct the new transition function 
\begin_inset Formula $\delta'$
\end_inset

 as follows:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\delta'(R,a)=\bigcup_{r\in R}\delta(r,a)\mbox{.}
\]

\end_inset


\end_layout

\begin_layout Definition
Now we need to consider the 
\begin_inset Formula $\epsilon$
\end_inset

 arrows, some of which contain tags.
 We use the following notation:
\end_layout

\begin_layout Definition
For any state 
\begin_inset Formula $R$
\end_inset

 of 
\begin_inset Formula $M$
\end_inset

 we define 
\begin_inset Formula $E(R)=\bigcup_{(r,t)\in R}e(q,t)$
\end_inset

 to be a set of pairs.
 The first elements of the pairs are the states that can be reached from
 
\begin_inset Formula $R$
\end_inset

 by going along only 
\begin_inset Formula $\epsilon$
\end_inset

-arrows, including the members of 
\begin_inset Formula $R$
\end_inset

 themselves.
 The second element of each pair denotes the memory locations of all tags
 for their corresponding NFA state.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Still a bit cryptic.
\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
Name:   
\begin_inset Formula $epsilonClosure(q,x)$
\end_inset


\end_layout

\begin_layout LyX-Code
Input:  DFA state Q, character to consume 
\begin_inset Formula $chr$
\end_inset


\end_layout

\begin_layout LyX-Code
Output: 
\begin_inset Formula $R$
\end_inset

 is the new DFA state, 
\begin_inset Formula $instructions$
\end_inset

 are the instructions that need to be executed.
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Formula $R\leftarrow\{\}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
Initialize empty stack 
\begin_inset Formula $low$
\end_inset


\end_layout

\begin_layout LyX-Code
Initialize empty stack 
\begin_inset Formula $high$
\end_inset


\end_layout

\begin_layout LyX-Code
1.
 Consuming the input
\end_layout

\begin_layout LyX-Code
For every transition 
\begin_inset Formula $t$
\end_inset

 from any of 
\begin_inset Formula $q\in Q$
\end_inset

 to 
\begin_inset Formula $q'$
\end_inset

 that consumes 
\begin_inset Formula $chr$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
if 
\begin_inset Formula $t$
\end_inset

 has high priority, push 
\begin_inset Formula $q'$
\end_inset

 to 
\begin_inset Formula $high$
\end_inset

, else to 
\begin_inset Formula $low$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
2.
 Following 
\begin_inset Formula $\varepsilon$
\end_inset

-transitions
\end_layout

\begin_layout LyX-Code
While 
\begin_inset Formula $high$
\end_inset

 and 
\begin_inset Formula $low$
\end_inset

 are not both empty
\end_layout

\begin_deeper
\begin_layout LyX-Code
pop 
\begin_inset Formula $q'$
\end_inset

 with store 
\begin_inset Formula $[l_{1},\dots,l_{n}]$
\end_inset

 from 
\begin_inset Formula $high$
\end_inset

 if possible, else from 
\begin_inset Formula $low$
\end_inset


\end_layout

\begin_layout LyX-Code
if 
\begin_inset Formula $q'\in R$
\end_inset

 jump to start of while loop
\end_layout

\begin_layout LyX-Code
add 
\begin_inset Formula $q'$
\end_inset

 to 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout LyX-Code
for all transitions 
\begin_inset Formula $t$
\end_inset

 from 
\begin_inset Formula $q'$
\end_inset

 to 
\begin_inset Formula $q''$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
2.1.
 continue if 
\begin_inset Formula $q'$
\end_inset

 has been seen:
\end_layout

\begin_layout LyX-Code
if 
\begin_inset Formula $q''\in R$
\end_inset

 jump to start of for loop to avoid conflict.
\end_layout

\begin_layout LyX-Code
if 
\begin_inset Formula $t$
\end_inset

 is tagged with 
\begin_inset Formula $\tau_{i}\uparrow$
\end_inset

 or 
\begin_inset Formula $\tau_{i}\downarrow$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
2.2.
 Compute new memory locations
\end_layout

\begin_layout LyX-Code
Copy 
\begin_inset Formula $l$
\end_inset

 as 
\begin_inset Formula $newHistories$
\end_inset


\end_layout

\begin_layout LyX-Code
Create new history cell 
\begin_inset Formula $h$
\end_inset

 and put it into 
\begin_inset Formula $position_{open}(i)$
\end_inset

 of 
\begin_inset Formula $newHistories$
\end_inset


\end_layout

\begin_layout LyX-Code
2.3.
 new instructions:
\end_layout

\begin_layout LyX-Code
put 
\begin_inset Formula $h\leftarrow l[position_{open}(i)]$
\end_inset

 into 
\begin_inset Formula $instructions$
\end_inset


\end_layout

\begin_layout LyX-Code
if 
\begin_inset Formula $t$
\end_inset

 has the opening tag 
\begin_inset Formula $\tau_{i}\uparrow$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
put 
\begin_inset Formula $h\leftarrow\pos+1$
\end_inset

 into instructions to store new start of the group.
\end_layout

\end_deeper
\begin_layout LyX-Code
else if 
\begin_inset Formula $t$
\end_inset

 has the closing tag 
\begin_inset Formula $\tau_{i}\downarrow$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
Create new history cell 
\begin_inset Formula $h'$
\end_inset

 and put it into 
\begin_inset Formula $position_{close}(i)$
\end_inset

 of 
\begin_inset Formula $newHistories$
\end_inset


\end_layout

\begin_layout LyX-Code
put 
\begin_inset Formula $h'\leftarrow l[position_{close}(i)]$
\end_inset

 into 
\begin_inset Formula $instructions$
\end_inset


\end_layout

\begin_layout LyX-Code
put 
\begin_inset Formula $h'\leftarrow\pos$
\end_inset

 into instructions
\end_layout

\begin_layout LyX-Code
put 
\begin_inset Formula $c\uparrow(h)$
\end_inset

 and 
\begin_inset Formula $c\downarrow(h')$
\end_inset

 into instructions to commit them into the immutable history of this thread.
\end_layout

\end_deeper
\begin_layout LyX-Code
end if
\end_layout

\end_deeper
\begin_layout LyX-Code
else
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $newHistories\leftarrow[l_{1},\dots,l_{n}]$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
end if
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
2.4.
 Push according to priority of transition:
\end_layout

\begin_layout LyX-Code
if 
\begin_inset Formula $t$
\end_inset

 has low priority, push 
\begin_inset Formula $q''$
\end_inset

 with 
\begin_inset Formula $newHistories$
\end_inset

 to 
\begin_inset Formula $low$
\end_inset

, else to 
\begin_inset Formula $high$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
end for
\end_layout

\end_deeper
\begin_layout LyX-Code
end while
\end_layout

\begin_layout LyX-Code
return 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Compute the follow-up state for DFA state 
\begin_inset Formula $M$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\delta^{\star}(R,a)=\{q\in Q:q\in E(\delta(r,a))\text{ for some }r\in R\}
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/automaton.pdf
	width 69text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:example-automaton"

\end_inset

Automaton for ((b+)|a)+ with group 0 tags omitted for clarity
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
Computing the next state from the DFA state 
\begin_inset Formula $(1[2,5,3,4],2[6,5,3,4],3[2,0,3,1],4[2,0,3,1],5[2,0,3,1],6[2,0,3,4],7[2,0,3,4],8[2,5,3,4])$
\end_inset

, which is the state after reading a single 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 input, in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:example-automaton"

\end_inset

: 
\end_layout

\begin_layout Enumerate
Since only 
\begin_inset Formula $3$
\end_inset

 has a 
\begin_inset Formula $b$
\end_inset

 transition and no tags are written in consuming transitions, 
\begin_inset Formula $high=(4[2,0,3,1])$
\end_inset

 after the initializing for loop
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $4[2,0,3,1]$
\end_inset

 is taken from the stack and added to 
\begin_inset Formula $R$
\end_inset

, which is now 
\begin_inset Formula $\{4[2,0,3,1]\}$
\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
possible optimization: only add if state has non-
\begin_inset Formula $\epsilon$
\end_inset

 transitions
\end_layout

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Enumerate
The transition 
\begin_inset Formula $4\rightarrow5$
\end_inset

 might be analysed first, but is added to 
\begin_inset Formula $low$
\end_inset

, because for greedy consumption in the 
\begin_inset Formula $+$
\end_inset

 operator, the backward way is prefered.
 The memory is not changed here.
\end_layout

\begin_layout Enumerate
Then the transition 
\begin_inset Formula $4\rightarrow3$
\end_inset

 is analysed and 
\begin_inset Formula $3$
\end_inset

 is added to 
\begin_inset Formula $high$
\end_inset

 without changes in the memory.
\end_layout

\end_deeper
\begin_layout Enumerate
Now the state 
\begin_inset Formula $3[2,0,3,1]$
\end_inset

 is taken from the stack and added to 
\begin_inset Formula $R$
\end_inset

, but since it has no 
\begin_inset Formula $\epsilon$
\end_inset

 exits, no further steps are taken from here
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $4[2,0,3,1]$
\end_inset

 leads to 
\begin_inset Formula $5[2,0,3,1]$
\end_inset


\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $5[2,0,3,1]$
\end_inset

 leads to 
\begin_inset Formula $6[2,0,3,7]$
\end_inset

, because 
\begin_inset Formula $\tau$
\end_inset

 is closed here.
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $6[2,0,3,7]$
\end_inset

 leads to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $7[2,0,3,7]$
\end_inset

.
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $7[2,0,3,7]$
\end_inset

 leads to 
\begin_inset Formula $8[2,8,3,7]$
\end_inset

, closing the 
\begin_inset Formula $\sigma$
\end_inset

 tag.
 
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $8[2,8,3,7]$
\end_inset

 leads to 
\begin_inset Formula $1[2,8,3,7]$
\end_inset


\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $1[2,8,3,7]$
\end_inset

 leads to 
\begin_inset Formula $2[9,8,3,7]$
\end_inset

, reopening 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Enumerate
The state 
\begin_inset Formula $2[9,8,3,7]$
\end_inset

 would lead to 
\begin_inset Formula $3[9,8,10,7]$
\end_inset

, it is however not added to 
\begin_inset Formula $R$
\end_inset

, because there is a different 
\begin_inset Formula $3$
\end_inset

 state (namely 
\begin_inset Formula $3[4,1,5,3]$
\end_inset

) in 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate
Now, a mapping is searched by comparing the new DFA state 
\begin_inset Formula $(1[2,8,3,7],2[9,8,3,7],3[2,0,3,1],4[2,0,3,1],5[2,0,3,1],6[2,0,3,7],7[2,0,3,7],8[2,8,3,7])$
\end_inset

 to any old states, in our case 
\begin_inset Formula $(1[2,5,3,4],2[6,5,3,4],3[2,0,3,1],4[2,0,3,1],5[2,0,3,1],6[2,0,3,4],7[2,0,3,4],8[2,5,3,4])$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Now the first NFA state has the memory 
\begin_inset Formula $[2,8,3,7]$
\end_inset

 in the new state and 
\begin_inset Formula $[2,5,3,4]$
\end_inset

 in the old state.
 This adds the following constraints:
\end_layout

\begin_deeper
\begin_layout Enumerate
Memory locations 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $3$
\end_inset

 is mapped to themselves
\end_layout

\begin_layout Enumerate
Memory location 
\begin_inset Formula $8$
\end_inset

 is mapped to 
\begin_inset Formula $5$
\end_inset


\end_layout

\begin_layout Enumerate
Memory location 
\begin_inset Formula $7$
\end_inset

 is mapped to 
\begin_inset Formula $4$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The second NFA state has the memory 
\begin_inset Formula $[9,8,3,7]$
\end_inset

 and 
\begin_inset Formula $[6,5,3,4]$
\end_inset

 respectively.
\end_layout

\begin_deeper
\begin_layout Enumerate
Memory location 
\begin_inset Formula $9$
\end_inset

 is mapped to 
\begin_inset Formula $6$
\end_inset


\end_layout

\begin_layout Enumerate
Memory location 
\begin_inset Formula $8$
\end_inset

 is mapped to 
\begin_inset Formula $5$
\end_inset

, which conforms to the given constraint from earlier
\end_layout

\begin_layout Enumerate
Memory location 
\begin_inset Formula $7$
\end_inset

 is mapped to 
\begin_inset Formula $4$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The third, forth, and fifth NFA state has identical memory, which introduces
 the constraints for 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
The sixth and seventh NFA state conforms to the mapping of 
\begin_inset Formula $7$
\end_inset

 to 
\begin_inset Formula $4$
\end_inset


\end_layout

\begin_layout Enumerate
The eighth NFA state conforms to the mapping of 
\begin_inset Formula $8$
\end_inset

 to 
\begin_inset Formula $5$
\end_inset

.
\end_layout

\begin_layout Enumerate
This means that the new state is isomorphic to an existing state and the
 mapping has been explicitly constructed.
 The newly introduced locations are assigned the position of character read.
\end_layout

\end_deeper
\begin_layout Section
TDFA with commits
\begin_inset CommandInset label
LatexCommand label
name "sec:TNFA-with-hierarchical"

\end_inset


\end_layout

\begin_layout Standard
The overall idea is simple: whenever the TDFA is reading in a run of characters
 that belong to a capture group, we push the previous one into our history
 and the work on current one.
 To implement this, we introduce 
\begin_inset Quotes eld
\end_inset

commits
\begin_inset Quotes erd
\end_inset

 into the TDFA.
 On the level on the TNFA the commits correspond to tags at the end of capture
 groups.
 Since capture groups are nested, they form a tree.
 We will call this three the match tree and will prove that we can reconstruct
 it.
 In it, we store all runs that this capture group matches.
 The subnodes of a hierarchy nodes correspond to the submatches of its capture
 group.We will shortly discuss how to construct a TDFA that includes instructions
 that 
\emph on
commit
\emph default
 submatches into the hierarchy nodes..
 Once we have the instructions, during interpretation of the TDFA, whenever
 we encounter an input character that closes a capture group, the TDFA will
 
\emph on
commit
\emph default
 that capture group.
 To commit a substring into a hierarchy node has the following semantics.
\end_layout

\begin_layout Standard
A hierarchy node, as a tree node, has a corresponding subtree.
 The data in this subtree represents precisely the subtree of the AST that
 is currently being matched.
 Upon commit of the hierarchy node, it constructs this AST subtree, and
 stores it as a previous match.
 Iteratively, this produces all matches of all capture groups.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/lehrer_match.pdf
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/lehrer_after.pdf
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Matching 
\family typewriter
(
\backslash
w+) (
\backslash
w+)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
if the current set of characters compare the current reading with the previously
 longest read, keeping the longer one.
 n order to get some more control over the overwriting of the tags, a separate
 
\family typewriter
commit
\family default
 step can be introduced.
 Each nesting then would need a separate copy of the temporary 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 match for a given group.
 For example 
\family typewriter
(((a+)b)+c)+
\family default
 would need two additional copies of the innermost group, to handle conflicts.
 
\end_layout

\begin_layout Plain Layout
The intuition is to notice that two tags -- the opening and the corresponding
 end tag -- always appear in order and the inner groups should not spill
 over the end of the outer group.
 After each closing tag then a commit is made, which handles whether the
 new or the old match is longer.
 
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename graphs/abc.pdf
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
NFA about to be transformed.
\end_layout

\end_inset


\end_layout

\end_inset

In the following, the regex 
\family typewriter
(((a+)b)+c)+
\family default
 will be converted to a 
\shape smallcaps
dfa
\shape default
 lazily while matching the string 
\begin_inset Quotes eld
\end_inset

abaababc
\begin_inset Quotes erd
\end_inset

, the resulting DFA can be seen in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:lazy-dfa"

\end_inset

:
\end_layout

\begin_layout Enumerate
The starting state is 
\begin_inset Formula $(1[-1,-2],2[0,-2])$
\end_inset

 and the memory location 
\begin_inset Formula $0$
\end_inset

 is initialized to hold the index 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Enumerate
Now the letter a is read:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $2[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $3[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $2[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $4[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $4[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $5[0,1]$
\end_inset

, with the instruction to write the index to 
\begin_inset Formula $1$
\end_inset

 and commit the memory locations 
\begin_inset Formula $(0,1)$
\end_inset

 on level 
\begin_inset Formula $3$
\end_inset

 afterwards.
 The hierarchical memory is now 
\begin_inset Formula $c_{1}=nil,c_{2}=nil,c_{3}=(0,1)$
\end_inset

, where 
\begin_inset Formula $(0,1)$
\end_inset

 are the indeces, not the memory locations
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Um, we might need to introduce a better notation
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter b is read:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $5[0,1]$
\end_inset

 leads to 
\begin_inset Formula $6[0,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $6[0,1]$
\end_inset

 leads to 
\begin_inset Formula $1[0,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $1[0,1]$
\end_inset

 leads to 
\begin_inset Formula $2[2,1]$
\end_inset

, with the instruction to write the current index to 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $6[0,1]$
\end_inset

 leads to 
\begin_inset Formula $7[0,1]$
\end_inset


\end_layout

\begin_layout Enumerate
7[0,1] leads to 
\begin_inset Formula $8[0,1]$
\end_inset

, with the instruction to commit to the second level.
 The hierarchical memory is now 
\begin_inset Formula $c_{1}=nil,c_{2}=(0,1),c_{3}=(0,1)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter a is read:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $2[2,1]$
\end_inset

 leads to 
\begin_inset Formula $3[2,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[2,1]$
\end_inset

 leads to 
\begin_inset Formula $2[2,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[2,1]$
\end_inset

 leads to 
\begin_inset Formula $4[2,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $4[2,1]$
\end_inset

 leads to 
\begin_inset Formula $5[2,3]$
\end_inset

, with the instruction to write the current index to memory location 
\begin_inset Formula $3$
\end_inset

 and commit the third level: 
\begin_inset Formula $c_{1}=nil,c_{2}=(0,1),c_{3}=(2,3)$
\end_inset


\end_layout

\begin_layout Enumerate
We find, that this state is mappable to the previous state 
\begin_inset Formula $(2[0,-2],3[0,-2],4[0,-2],5[0,1])$
\end_inset

 with the mapping 
\begin_inset Formula $2\rightarrow0,1\rightarrow-2$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter a is read:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $2[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $3[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $2[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $3[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $4[0,-2]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $4[0,-2]$
\end_inset

 leads to 
\begin_inset Formula $5[0,1]$
\end_inset

, with the instruction to write the current index to memory location 
\begin_inset Formula $1$
\end_inset

 and commit the third level: 
\begin_inset Formula $c_{1}=nil,c_{2}=(0,1),c_{3}=(2,4)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter b is read, but the transition is already known:
\end_layout

\begin_deeper
\begin_layout Enumerate
We write the current index into memory location 
\begin_inset Formula $2$
\end_inset

 and commit the second level.
 Now the match 
\begin_inset Formula $(2,4)$
\end_inset

 is compared against the previous match 
\begin_inset Formula $(0,1)$
\end_inset

, but the length of the new match is bigger, therefore the new match overwrites
 the old one.
 
\begin_inset Formula $c_{1}=nil,c_{2}=(2,4),c_{3}=(2,4)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter a is read, but the transition is already known:
\end_layout

\begin_deeper
\begin_layout Enumerate
We write the current index into memory location 
\begin_inset Formula $-2$
\end_inset

 (because of the mapping) and commit 
\begin_inset Formula $(2,-2)$
\end_inset

 to the third level.
 
\begin_inset Formula $c_{1}=nil,c_{2}=(2,4),c_{3}=(5,6)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter b is read, but the transition is already known:
\end_layout

\begin_deeper
\begin_layout Enumerate
We write the current index into memory location 
\begin_inset Formula $2$
\end_inset

 and commit to the second level.
 The match 
\begin_inset Formula $(5,6)$
\end_inset

 is compared against the previous match 
\begin_inset Formula $(2,4)$
\end_inset

, but the length of the old match is bigger, therefore the old match is
 kept.
 
\begin_inset Formula $c_{1}=nil,c_{2}=(2,4),c_{3}=(5,6)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Next the letter c is read:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $8[0,1]$
\end_inset

 leads to 
\begin_inset Formula $9[0,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $9[0,1]$
\end_inset

 leads to 
\begin_inset Formula $1[0,1]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $1[0,1]$
\end_inset

 leads to 
\begin_inset Formula $2[2,1]$
\end_inset

, with the instruction to write the current index to memory location 
\begin_inset Formula $2$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $9[0,1]$
\end_inset

 leads to 
\begin_inset Formula $10[0,1]$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $10[0,1]$
\end_inset

 leads to 
\begin_inset Formula $11[0,1]$
\end_inset

, with the instruction to commit to the first level.
 
\begin_inset Formula $c_{1}=(2,4),c_{2}=(2,4),c_{3}=(5,6)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Finally the end of the string is read.
\end_layout

\begin_deeper
\begin_layout Enumerate
We are in a finishing state 
\begin_inset Formula $11[0,1]$
\end_inset

, therefore the match succeeds.
 The current commit of the top layer is returned: 
\begin_inset Formula $c_{1}=(2,4)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename graphs/abc-dfa.pdf
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:lazy-dfa"

\end_inset

The DFA of 
\family typewriter
(?:(?:(a+)b)+c)+
\family default
 matching 
\begin_inset Quotes eld
\end_inset

abaababc
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
This technique allows for programmers to extract parts of text with great
 performance and flexibility regarding the extracted match.
 One could imagine, that a programmer needs to extract a ideally complete
 sample of formated text with optional parameters.
 Here, 
\family typewriter
\shape smallcaps
posix
\family default
\shape default
 regex would fail to deliver the best match in most cases.
 Such cases can occur in data mining, in bioinformatics, both of which are
 handling massive data, so that efficiency can be a problem.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Benchmarks
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section
Open questions
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio"
options "plain"

\end_inset


\end_layout

\begin_layout Section*
Notes: 
\end_layout

\begin_layout Standard
Pseudocode
\end_layout

\begin_layout Standard
Beispiel(e) '(?:(?:(a+)b)+c)+'
\end_layout

\begin_layout Standard
Algorithm:
\end_layout

\begin_layout Standard
Definition:
\end_layout

\end_body
\end_document
