#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Efficient regexp implementation for finding the longest matching groups
\end_layout

\begin_layout Abstract
The 
\shape smallcaps
posix
\shape default
 standard seems inconsistent in that it prescribes on one hand to prefer
 the longest and left-most match but the right-most combination no matter
 the length.
 While this seems reasonable if one is familiar with typical implementations,
 it can lead to unintuitive matches: 
\end_layout

\begin_layout Abstract
Given the regexp
\begin_inset Foot
status open

\begin_layout Plain Layout
Non-capturing groups will be used to simplify examples.
\end_layout

\end_inset

 
\family typewriter
(?:(a*)b)+
\family default
 and the string 
\family typewriter
aaabb
\family default
 one might expect to match 
\family typewriter
aaa
\family default
, i.e.
 the longest match, but by 
\shape smallcaps
posix
\shape default
 standard 1003.1, the empty string is the result instead, i.e.
 the right-most matching group.
\end_layout

\begin_layout Abstract
The more intuitive match does not lead to efficiency problems.
 As we will show, the TDFA algorithm by Laurikari
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 can be modified using hierarchical commits to give an algorithm with only
 a linear slowdown in the depth of the capture group nesting in the worst
 case.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The algorithm in 
\begin_inset CommandInset citation
LatexCommand cite
key "laurikari2000nfas"

\end_inset

 uses NFAs in which some transitions tag the resulting state.
 A tagged state 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 is neither equivalent to the untagged state 
\begin_inset Formula $s_{0}$
\end_inset

 nor the same state tagged at a different time 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

.
 To ensure that there are only finitely different tagged states--and thus
 to ensure that the conversion to a DFA terminates--, 
\begin_inset Formula $s_{0}m_{0}^{0}$
\end_inset

 and 
\begin_inset Formula $s_{0}m_{0}^{1}$
\end_inset

 (but not 
\begin_inset Formula $s_{0}$
\end_inset

) are understood to be in conflict.
 Conflicts are resolved with priorities being attached to the transitions,
 e.g.
 the greedy consumption in 
\family typewriter
a*
\family default
 will have priority over other transitions and thus a tag that is produced
 right after such a transition is prefered to another, that resulted from
 a forward 
\begin_inset Formula $\varepsilon$
\end_inset

\SpecialChar \nobreakdash-
transition.
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-TNFA-algorithm"

\end_inset

 the TNFA algorithm is presented so that the modifications in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TNFA-with-hierarchical"

\end_inset

 can be understood more easily.
\end_layout

\begin_layout Section
The TNFA algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:The-TNFA-algorithm"

\end_inset


\end_layout

\begin_layout Standard
In the TNFA algorithm, the state of the machine is not only determined by
 the position in the state graph, but also by a number of positions in the
 string that is read, that can later be used to construct the subgroups
 of the match.
 
\end_layout

\begin_layout Section
TNFA with hierarchical commits
\begin_inset CommandInset label
LatexCommand label
name "sec:TNFA-with-hierarchical"

\end_inset


\end_layout

\begin_layout Standard
In order to get some more control over the overwriting of the tags, a separate
 
\family typewriter
commit
\family default
 step can be introduced.
 Each nesting then would need a separate copy of the temporary 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 match for a given group.
 For example 
\family typewriter
(?:(?:(a+)b)+c)+
\family default
 would need two additional copies of the innermost group, to handle conflicts.
 
\end_layout

\begin_layout Standard
The intuition is to notice that two tags -- the opening and the corresponding
 end tag -- always appear in order and the inner groups should not spill
 over the end of the outer group.
 After each closing tag then a commit is made, which handles whether the
 new or the old match is longer.
 
\end_layout

\begin_layout Section
Applications
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio"
options "plain"

\end_inset


\end_layout

\begin_layout Section*
Notes: 
\end_layout

\begin_layout Standard
Pseudocode
\end_layout

\begin_layout Standard
Beispiel(e) '(?:(?:(a+)b)+c)+'
\end_layout

\begin_layout Standard
Algorithm:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
step
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Function{SimpleStep}{$nfa$, $node$, $read$} 
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return $
\backslash
{(n, t, priority) : (node, n, read, t, priority) 
\backslash
in nfa.transitions
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{ResolveConflicts}{$map$}
\end_layout

\begin_layout Plain Layout


\backslash
State $flat 
\backslash
gets 
\backslash
text{recusively all } keys 
\backslash
text{ of } map$
\end_layout

\begin_layout Plain Layout


\backslash
ForAll{conflicting $N_1 = (n, m_{t_1}, p_1), N_2 = (n, m_{t_2}, p_2) 
\backslash
in flat$}
\end_layout

\begin_layout Plain Layout

	
\backslash
If{$p_2 > p_1$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State remove $N_1$ from map
\backslash
Comment{Also removes dependent states}
\end_layout

\begin_layout Plain Layout

	
\backslash
Else
\end_layout

\begin_layout Plain Layout

		
\backslash
State remove $N_2$ from map
\end_layout

\begin_layout Plain Layout

	
\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return flat
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{Step}{$nfa$, $node$, $read$}
\end_layout

\begin_layout Plain Layout


\backslash
State $direct 
\backslash
gets 
\backslash
Call{SimpleStep}{nfa, node, read}$
\end_layout

\begin_layout Plain Layout


\backslash
State $map 
\backslash
gets Map(n 
\backslash
rightarrow step(nfa, n, 
\backslash
varepsilon) : n 
\backslash
in direct)$
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return 
\backslash
Call{ResolveConflicts}{map}
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{PushStates}{nfa, dfa, start}
\end_layout

\begin_layout Plain Layout


\backslash
State $open 
\backslash
gets 
\backslash
{start
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
State $towards 
\backslash
gets 
\backslash
text{empty }Map
\backslash
left[readable 
\backslash
rightarrow Set
\backslash
left[NfaState
\backslash
right]
\backslash
right]$
\end_layout

\begin_layout Plain Layout


\backslash
While{$open 
\backslash
neq 
\backslash
emptyset$}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $first:open 
\backslash
gets open$
\end_layout

\begin_layout Plain Layout

	
\backslash
ForAll{$state_{nfa} 
\backslash
in first$ and valid inputs $r$ from $state_{nfa}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $towards[r] 
\backslash
gets towards 
\backslash
cup 
\backslash
Call{step}{nfa, state_{nfa}, r}$
\end_layout

\begin_layout Plain Layout

	
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

	
\backslash
State $dfa.transitions, newnodes 
\backslash
gets 
\backslash
Call{Merge}{dfa.transitions, towards}$
\end_layout

\begin_layout Plain Layout

	
\backslash
Statex 
\backslash
Comment{Merge depends on the match strategy}
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return dfa
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
Statex
\end_layout

\begin_layout Plain Layout


\backslash
Function{CreateDfa}{nfa}
\end_layout

\begin_layout Plain Layout


\backslash
State initialize empty dfa
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa.start 
\backslash
gets nfa.start 
\backslash
cup 
\backslash
Call{Step}{nfa, nfa.start, 
\backslash
varepsilon}$
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa 
\backslash
gets 
\backslash
Call{PushStates}{nfa, dfa, dfa.start}$
\end_layout

\begin_layout Plain Layout


\backslash
State $dfa.ends 
\backslash
gets 
\backslash
{n
\backslash
in dfa.states : n
\backslash
cap nfa.ends 
\backslash
neq 
\backslash
emptyset
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
State 
\backslash
Return dfa
\end_layout

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
