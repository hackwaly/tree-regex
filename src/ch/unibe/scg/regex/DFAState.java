package ch.unibe.scg.regex;

import static java.util.Objects.requireNonNull;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

class DFAState implements Comparable<DFAState> {
  private static final int BYTES_PER_LONG = 8;
  private static final int BYTES_PER_INT = 4;

  final List<RThread> threads;
  final private byte[] comparisonKey;
  /** Histories of this state if it is finishing, otherwise null. */
  final Arraylike finalHistories;

  DFAState(final List<RThread> threads, byte[] comparisonKey, Arraylike finalHistories) {
    this.comparisonKey = requireNonNull(comparisonKey); // Needed for equals.
    this.threads = threads;
    this.finalHistories = finalHistories;
  }

  /**
   * @return a key that specifies an ordering of inner states by inner states first, then by histories.
   * The returned key is the concatenation of two parts, first the part that represents the states,
   * then the part that represents the histories.
   *
   * <p> The first part is generated by {@link #makeStateComparisonKey(Set)}.
   */
  static byte[] makeComparisonKey(List<RThread> innerStates) {
    assert !innerStates.isEmpty();

    byte[] firstPart = makeStateComparisonKey(innerStates);
    byte[] secondPart = makeHistoryComparisonKey(innerStates);

    // concatenate both parts.
    byte[] ret = new byte[firstPart.length + secondPart.length];
    System.arraycopy(firstPart, 0, ret, 0, firstPart.length);
    System.arraycopy(secondPart, 0, ret, firstPart.length, secondPart.length);
    return ret;
  }

  /** @return a key that specifies an ordering of {@code Set<State>}. */
  static byte[] makeStateComparisonKey(List<RThread> threads) {
    MessageDigest md = makeMessageDigest();
    ByteBuffer intBuf = ByteBuffer.allocate(BYTES_PER_INT);
    for (RThread t : threads) {
      intBuf.rewind();
      intBuf.putInt(t.state.getId());
      intBuf.rewind();
      md.update(intBuf);
    }

    return md.digest();
  }

  private static byte[] makeHistoryComparisonKey(List<RThread> threads)
      throws AssertionError {
    ByteBuffer longBuf = ByteBuffer.allocate(BYTES_PER_LONG);
    MessageDigest md = makeMessageDigest();
    for (RThread t : threads) {
      for (History h : t.histories) {
        longBuf.rewind();
        longBuf.putLong(h.id);
        longBuf.rewind();
        md.update(longBuf);
      }
    }
    return md.digest();
  }

  private static MessageDigest makeMessageDigest() throws AssertionError {
    MessageDigest md;
    try {
      md = MessageDigest.getInstance("MD5");
    } catch (NoSuchAlgorithmException e) {
      throw new AssertionError(e); // Guaranteed to exist.
    }
    return md;
  }

  @Override
  public int compareTo(final DFAState that) {
    return ByteBuffer.wrap(this.comparisonKey).compareTo(ByteBuffer.wrap(that.comparisonKey));
  }

  @Override
  public boolean equals(final Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final DFAState other = (DFAState) obj;

    return Arrays.equals(comparisonKey, other.comparisonKey);
  }

  @Override
  public int hashCode() {
    int ret = 0;
    for (byte b : comparisonKey) {
      ret *= 31;
      ret ^= b;
    }
    return ret;
  }

  @Override
  public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append('(');
    for (RThread el : threads) {
      sb.append(el.state);
      sb.append("->");
      sb.append(el.histories.toString());
      sb.append(", ");
    }
    sb.delete(sb.length() - 2, sb.length());
    sb.append(')');
    return sb.toString();
  }
}