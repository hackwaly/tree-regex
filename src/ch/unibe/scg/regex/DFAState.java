package ch.unibe.scg.regex;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

class DFAState implements Comparable<DFAState> {
  private static final int BYTES_PER_LONG = 8;
  private static final int BYTES_PER_INT = 4;

  final LinkedHashMap<State, History[]> innerStates;
  final private byte[] comparisonKey;

  DFAState(final LinkedHashMap<State, History[]> map, byte[] comparisonKey) {
    this.comparisonKey = comparisonKey;
    this.innerStates = map;
  }

  /**
   * @return a key that specifies an ordering of inner states by inner states first, then by histories.
   * The returned key is the concatenation of two parts, first the part that represents the states,
   * then the part that represents the histories.
   *
   * <p> The first part is generated by {@link #makeStateComparisonKey(Set)}.
   */
  static byte[] makeComparisonKey(LinkedHashMap<State, History[]> innerStates) {
    assert !innerStates.isEmpty();

    byte[] firstPart = makeStateComparisonKey(innerStates);
    byte[] secondPart = makeHistoryComparisonKey(innerStates);

    // concatenate both parts.
    byte[] ret = new byte[firstPart.length + secondPart.length];
    System.arraycopy(firstPart, 0, ret, 0, firstPart.length);
    System.arraycopy(secondPart, 0, ret, firstPart.length, secondPart.length);
    return ret;
  }

  /** @return a key that specifies an ordering of {@code Set<State>}. */
  static byte[] makeStateComparisonKey(LinkedHashMap<State, History[]> map) {
    MessageDigest md = makeMessageDigest();
    ByteBuffer intBuf = ByteBuffer.allocate(BYTES_PER_INT);
    for (Entry<State, History[]> e : map.entrySet()) {
      intBuf.rewind();
      State state = e.getKey();
      intBuf.putInt(state.getId());
      intBuf.rewind();
      md.update(intBuf);
    }

    return md.digest();
  }

  private static byte[] makeHistoryComparisonKey(LinkedHashMap<State, History[]> innerStates)
      throws AssertionError {
    ByteBuffer longBuf = ByteBuffer.allocate(BYTES_PER_LONG);
    MessageDigest md = makeMessageDigest();
    for (Entry<State, History[]> entry : innerStates.entrySet()) {
      for (History h : entry.getValue()) {
        longBuf.rewind();
        longBuf.putLong(h.id);
        longBuf.rewind();
        md.update(longBuf);
      }
    }
    return md.digest();
  }

  private static MessageDigest makeMessageDigest() throws AssertionError {
    MessageDigest md;
    try {
      md = MessageDigest.getInstance("MD5");
    } catch (NoSuchAlgorithmException e) {
      throw new AssertionError(e); // Guaranteed to exist.
    }
    return md;
  }

  @Override
  public int compareTo(final DFAState that) {
    return ByteBuffer.wrap(this.comparisonKey).compareTo(ByteBuffer.wrap(that.comparisonKey));
  }

  @Override
  public boolean equals(final Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final DFAState other = (DFAState) obj;
    if (innerStates == null) {
      if (other.innerStates != null) {
        return false;
      }
    }

    return Arrays.equals(comparisonKey, other.comparisonKey);
  }

  @Override
  public int hashCode() {
    if (innerStates == null) {
      return 1;
    }

    return innerStates.keySet().hashCode();
  }

  @Override
  public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append('(');
    for (final Map.Entry<State, History[]> el : innerStates.entrySet()) {
      sb.append(el.getKey());
      sb.append("->");
      sb.append(Arrays.toString(el.getValue()));
      sb.append(", ");
    }
    sb.delete(sb.length() - 2, sb.length());
    sb.append(')');
    return sb.toString();
  }
}