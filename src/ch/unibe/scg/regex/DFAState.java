package ch.unibe.scg.regex;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

class DFAState implements Comparable<DFAState> {
  private static final int BYTES_PER_LONG = 8;
  private static final int BYTES_PER_INT = 4;

  final static DFAState INSTRUCTIONLESS_NO_STATE
      = new DFAState(Collections.<State, History[]> emptyMap(), new byte[] {});

  final Map<State, History[]> innerStates;
  final private byte[] comparisonKey;

  DFAState(final Map<State, History[]> map, byte[] comparisonKey) {
    this.comparisonKey = comparisonKey;
    this.innerStates = map;
  }

  /**
   * @return a key that specifies an ordering of inner states by inner states first, then by histories.
   * The returned key is the concatenation of two parts, first the part that represents the states,
   * then the part that represents the histories.
   *
   * <p> The first part is generated by {@link #makeStateComparisonKey(Set)}.
   */
  static byte[] makeComparisonKey(Map<State, History[]> innerStates) {
    assert !innerStates.isEmpty();

    byte[] firstPart = makeStateComparisonKey(innerStates.keySet());
    byte[] secondPart = makeHistoryComparisonKey(innerStates);

    // concatenate both parts.
    byte[] ret = new byte[firstPart.length + secondPart.length];
    System.arraycopy(firstPart, 0, ret, 0, firstPart.length);
    System.arraycopy(secondPart, 0, ret, firstPart.length, secondPart.length);
    return ret;
  }

  /** @return a key that specifies an ordering of {@code Set<State>}. */
  static byte[] makeStateComparisonKey(Set<State> states) {
    List<State> sortedStates = new ArrayList<>(states);
    Collections.sort(sortedStates, new Comparator<State>() {
      @Override public int compare(State o1, State o2) {
        return Integer.compare(o1.getId(), o2.getId());
      }
    });

    MessageDigest md = makeMessageDigest();
    ByteBuffer intBuf = ByteBuffer.allocate(BYTES_PER_INT);
    for (State s : states) {
      intBuf.rewind();
      intBuf.putInt(s.getId());
      intBuf.rewind();
      md.update(intBuf);
    }

    return md.digest();
  }

  private static byte[] makeHistoryComparisonKey(Map<State, History[]> innerStates)
      throws AssertionError {
    List<Entry<State, History[]>> entries = new ArrayList<>(innerStates.entrySet());
    Collections.sort(entries, new Comparator<Entry<State, History[]>>() {
      @Override public int compare(Entry<State, History[]> x, Entry<State, History[]> y) {
        // This defines a total order because keys don't occur twice.
        return Integer.compare(x.getKey().getId(), y.getKey().getId());
      }
    });

    ByteBuffer longBuf = ByteBuffer.allocate(BYTES_PER_LONG);
    MessageDigest md = makeMessageDigest();
    for (Entry<State, History[]> entry : entries) {
      for (History h : entry.getValue()) {
        longBuf.rewind();
        longBuf.putLong(h.id);
        longBuf.rewind();
        md.update(longBuf);
      }
    }
    return md.digest();
  }

  private static MessageDigest makeMessageDigest() throws AssertionError {
    MessageDigest md;
    try {
      md = MessageDigest.getInstance("MD5");
    } catch (NoSuchAlgorithmException e) {
      throw new AssertionError(e); // Guaranteed to exist.
    }
    return md;
  }

  @Override
  public int compareTo(final DFAState that) {
    return ByteBuffer.wrap(this.comparisonKey).compareTo(ByteBuffer.wrap(that.comparisonKey));
  }

  @Override
  public boolean equals(final Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final DFAState other = (DFAState) obj;
    if (innerStates == null) {
      if (other.innerStates != null) {
        return false;
      }
    }

    return Arrays.equals(comparisonKey, other.comparisonKey);
  }

  @Override
  public int hashCode() {
    if (innerStates == null) {
      return 1;
    }

    return innerStates.keySet().hashCode();
  }

  @Override
  public String toString() {
    final StringBuilder sb = new StringBuilder();
    sb.append('(');
    for (final Map.Entry<State, History[]> el : innerStates.entrySet()) {
      sb.append(el.getKey());
      sb.append("->");
      sb.append(Arrays.toString(el.getValue()));
      sb.append(", ");
    }
    sb.delete(sb.length() - 2, sb.length());
    sb.append(')');
    return sb.toString();
  }
}