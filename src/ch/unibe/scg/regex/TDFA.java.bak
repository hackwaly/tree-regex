package automaton.core;

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import automaton.instructions.Context;
import automaton.instructions.SequenceOfInstructions;

/**
 * Class representing a simple {@link TDFA}
 * 
 * @author Fabien Dubosson
 */
public class TDFA {
	/**
	 * {@link Set} of valid {@link Character}s
	 */
	private final SortedSet<InputRange> alphabet;

	/**
	 * {@link Set} of final {@link State}s
	 */
	private final Map<State, SequenceOfInstructions> finalStates;

	/**
	 * Initial {@link State}
	 */
	private Pair<State, SequenceOfInstructions> initialState;

	/**
	 * {@link Set} of {@link State}s
	 */
	private final Set<State> states;

	/**
	 * {@link TransitionTable} representing all possible transition in
	 * {@link TDFA}
	 */
	private final TransitionTable transitionTable;

	/**
	 * Initialize a {@link TDFA}
	 */
	public TDFA() {
		this.states = new LinkedHashSet<>();
		this.alphabet = new TreeSet<>();
		this.transitionTable = new TransitionTable();
		this.finalStates = new TreeMap<State, SequenceOfInstructions>();
	}

	/**
	 * Add a {@link Character} into the alphabet
	 * 
	 * @param input
	 *            the {@link Character} to add
	 */
	private void addAlphabet(final InputRange input) {
		// TODO write method
	}

	/**
	 * Define a new {@link State} as a final {@link State} of {@link TDFA}
	 * 
	 * @param finalState
	 *            the {@link State} to define as final {@link State}
	 */
	public void addFinalState(final State finalState,
			final SequenceOfInstructions sequence) {
		this.finalStates.put(finalState, sequence);
		assert invariant();
	}

	/**
	 * Construct {@link TDFA} by adding new transition.
	 * 
	 * @param startingState
	 *            Starting {@link State} of the transition
	 * @param range
	 *            Assigned {@link Character}s of the transition
	 * @param endingState
	 *            Ending {@link State} of the transition
	 * @param instruction
	 *            Assigned {@link SequenceOfInstructions} to execute when using
	 *            the transition
	 */
	public void addTransition(final State startingState,
			final InputRange range, final State endingState,
			final SequenceOfInstructions instruction) {
		this.states.add(startingState);
		this.states.add(endingState);
		this.addAlphabet(range);
		// TODO Complete the method
		this.transitionTable
				.put(startingState, range, endingState, instruction);
		assert invariant();
	}

	/**
	 * Return an unmodifiable {@link Set} of all {@link Character}s of
	 * {@link TDFA}
	 * 
	 * @return an unmodifiable {@link Set} of {@link Character}s of {@link TDFA}
	 */
	public Set<InputRange> getAlphabet() {
		return Collections.unmodifiableSet(alphabet);
	}

	/**
	 * Calculate the alphabet of a {@link TransitionTable}
	 * 
	 * @param transitionTable2
	 * @return the {@link Set} of {@link Character}s representing the alphabet
	 */
	private Set<InputRange> getAlphabetFrom(
			final TransitionTable transitionTable2) {
		// TODO Auto-generated method stub
		return null;
	}

	public SequenceOfInstructions getFinalInstructions(final State state) {
		return this.finalStates.get(state);
	}

	/**
	 * Return an unmodifiable {@link Set} of all final {@link State}s of
	 * {@link TDFA}
	 * 
	 * @return an unmodifiable {@link Set} of final {@link State}s of
	 *         {@link TDFA}
	 */
	public Set<State> getFinalStates() {
		return Collections.unmodifiableSet(finalStates.keySet());
	}

	public SequenceOfInstructions getInitialInstructions() {
		return initialState.getSecond();
	}

	/**
	 * The initial {@link State} of {@link TDFA}
	 * 
	 * @return the initial {@link State} of {@link TDFA}
	 */
	public State getInitialState() {
		return initialState.getFirst();
	}

	/**
	 * Return an unmodifiable {@link Set} of all {@link State}s of {@link TDFA}
	 * 
	 * @return an unmodifiable {@link Set} of {@link State}s of {@link TDFA}
	 */
	public Set<State> getStates() {
		return Collections.unmodifiableSet(states);
	}

	/**
	 * Verify the consistency of the {@link TDFA}
	 * 
	 * @return <code>true</code> if the {@link TDFA} is consistent,
	 *         <code>false</code> otherwise
	 */
	protected boolean invariant() {
		final Set<InputRange> alphabetOfTransitions = getAlphabetFrom(transitionTable);
		return alphabetOfTransitions.equals(alphabet);
	}

	/**
	 * Define the initial {@link State} of the {@link TDFA}
	 * 
	 * @param initialState
	 *            The new initial {@link State} of {@link TDFA}
	 */
	public void setInitialState(final State initialState,
			final SequenceOfInstructions sequence) {
		this.initialState = new Pair<State, SequenceOfInstructions>(
				initialState, sequence);
	}

	public State step(final Context context, final int pos, final State start,
			final Character character) {
		final State result = this.transitionTable.getState(start, character);

		if (result != null) {
			this.transitionTable.getInstruction(start, character).execute(
					context, pos);
		}

		return result;
	}

}
